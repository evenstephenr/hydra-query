{"version":3,"file":"index.modern.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useReducer, useCallback, Dispatch } from \"react\";\r\n\r\nconst URLformat = ({ query }: { query: { [k: string]: string } }) => {\r\n  return `?${Object.keys(query).map((key) => `${key}=${query[key]}`)}`;\r\n};\r\n\r\nconst mergeRequestOptions = (\r\n  defaultOptions: RequestInit,\r\n  customOptions: RequestInit = {}\r\n): RequestInit => {\r\n  const defaultKeys = Object.keys(defaultOptions);\r\n  const customKeys = Object.keys(customOptions);\r\n  const sharedKeys = defaultKeys.concat(\r\n    customKeys.filter((k) => !defaultKeys.includes(k))\r\n  );\r\n  return sharedKeys.reduce((acc: RequestInit, key: keyof RequestInit) => {\r\n    const defaultValue = defaultOptions[key];\r\n    const customValue = customOptions[key];\r\n\r\n    if (typeof defaultValue === \"object\" && typeof customValue === \"object\") {\r\n      return {\r\n        ...acc,\r\n        [key]: {\r\n          ...defaultValue,\r\n          ...customValue,\r\n        },\r\n      };\r\n    }\r\n\r\n    return {\r\n      ...acc,\r\n      [key]: customValue || defaultValue,\r\n    };\r\n  }, {});\r\n};\r\n\r\n// TODO: make the default options configurable by useQuery\r\nconst setDefaultOptions = (): RequestInit => ({\r\n  method: \"GET\",\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n  mode: \"cors\",\r\n  cache: \"no-cache\",\r\n});\r\n\r\nconst request = (url: string, options?: RequestInit): Promise<Response> => {\r\n  const defaultOptions = setDefaultOptions();\r\n  const opts = mergeRequestOptions(defaultOptions, options);\r\n  return fetch(url, opts);\r\n};\r\n\r\n/**\r\n * QueryProps defines the properties required (or optionally used) to define\r\n *  a useQuery hook.\r\n *\r\n * QueryProps uses generics (received from a useQuery hook) to determine the following...\r\n *  1. what data is accessible in the useQuery hook\r\n *  2. what query params exist for the useQuery hook\r\n */\r\ntype QueryProps<Params> = {\r\n  /** All queries require a target endpoint */\r\n  endpoint: string;\r\n  /** All queries have optional params (defaults to `undefined`) */\r\n  params?: Params;\r\n  /**\r\n   * useQuery defaults to using the global `fetch` browser API\r\n   *  - you can provide your own external request util here as needed\r\n   */\r\n  requestUtil?: (\r\n    url: string,\r\n    options?: RequestInit | undefined\r\n  ) => Promise<Response>;\r\n  /**\r\n   * useQuery can optionally serve cached data, rather than what's provided by an\r\n   *  external `fetch`\r\n   *  - localStorage is used for the cache\r\n   *  - data provided by this hook will be cached using the given key passed by `withCache`\r\n   *  - the data that is cached will be replaced by any use of useQuery's `requestUtil`\r\n   * */\r\n  withCache?: string;\r\n  // TODO: add a flag here to 'cancel' requests (prevent data from updating if parent is unmounted)\r\n  //  - Should this be a base component you can pass reactnode children into?\r\n};\r\n/**\r\n * QueryState defines the stateful properties that are returned from every instance\r\n *  of a useQuery hook\r\n */\r\ntype QueryState<Data, Params> = {\r\n  /** If an external request is currently active, isLoading will be set to `true` */\r\n  isLoading: boolean;\r\n  /** The params used in the current or most recent instance of a useQuery hook */\r\n  params: Params | {};\r\n  /** The resulting URL used in the current or most recent instance of a useQuery hook */\r\n  url: string;\r\n  /** This will always match the endpoint defined in QueryProps */\r\n  endpoint?: string;\r\n  /** The data expected to be retrieved by a useQuery hook */\r\n  data?: Data;\r\n  /** Any error thrown by a useQuery hook will be communicated here */\r\n  error?: string;\r\n  /** If an error status code is returned from an external request, it will be populated here */\r\n  errorCode?: number;\r\n};\r\n/**\r\n * QueryFetch is exported here for typing use outside of this module\r\n *\r\n * ex:\r\n *  type FetchSomeType = QueryFetch<{ data: SomeType }, {}>;\r\n */\r\nexport type QueryFetch<Data, Params> = (config?: {\r\n  params?: Params;\r\n  options?: RequestInit;\r\n  /**\r\n   * `onResponse` can be used to mutate the data returned from your external source\r\n   *  - This function defaults to a noop wrapped in a Promise that immediately resolves\r\n   *  - if you supply your own handler here, it must be wrapped in a promise\r\n   */\r\n  onResponse?: (\r\n    data: any\r\n  ) => Promise<{\r\n    data: Data;\r\n  }>;\r\n}) => void;\r\n/**\r\n * QueryResult defines the properties that are returned from every instance\r\n *  of a useQuery hook.\r\n *\r\n * QueryResult extends QueryState\r\n *\r\n * QueryResult uses generics (received from a useQuery hook) to determine the following...\r\n *  1. what data is accessible in the useQuery hook\r\n *  2. what query params exist for the useQuery hook\r\n */\r\ntype QueryResult<Data, Params> = QueryState<Data, Params> & {\r\n  /**\r\n   * `fetch` can be used for controlled external data retrieval from whatever context\r\n   *  defines a useQuery hook\r\n   */\r\n  fetch: QueryFetch<Data, Params>;\r\n  // TODO: implement this\r\n  // /**\r\n  //  * `reset` sets the QueryState back to the original values passed in to the useQuery options\r\n  //  */\r\n  // reset: () => void;\r\n  /**\r\n   * this is generally useful for testing, you can also use it to wipe the state of the hook\r\n   */\r\n  dispatch: Dispatch<QueryActions<Data, Params>>;\r\n};\r\nexport enum ACTION {\r\n  RESET = \"reset\",\r\n  REFRESH = \"refresh\",\r\n  SUCCESS = \"success\",\r\n  ERROR = \"error\",\r\n}\r\ntype RESET_ACTION = { type: ACTION.RESET };\r\ntype REFRESH_ACTION<P> = {\r\n  type: ACTION.REFRESH;\r\n  url: string;\r\n  params?: P | {};\r\n};\r\ntype SUCCESS_ACTION<D> = {\r\n  type: ACTION.SUCCESS;\r\n  data: D;\r\n  prevPage?: string;\r\n  nextPage?: string;\r\n};\r\ntype ERROR_ACTION = { type: ACTION.ERROR; error: string; errorCode?: number };\r\ntype QueryActions<D, P> =\r\n  | RESET_ACTION\r\n  | REFRESH_ACTION<P>\r\n  | SUCCESS_ACTION<D>\r\n  | ERROR_ACTION;\r\nexport function useQueryReducer<Data, Params>(\r\n  state: QueryState<Data, Params>,\r\n  action: QueryActions<Data, Params>\r\n): QueryState<Data, Params> {\r\n  switch (action.type) {\r\n    case ACTION.RESET: {\r\n      return {\r\n        isLoading: false,\r\n        url: state.url,\r\n        params: state.params,\r\n      };\r\n    }\r\n    case ACTION.REFRESH: {\r\n      const { url: actionUrl, params = {} } = action;\r\n      return {\r\n        ...state,\r\n        url: actionUrl,\r\n        params,\r\n        isLoading: true,\r\n      };\r\n    }\r\n    case ACTION.SUCCESS: {\r\n      const { data } = action;\r\n      return {\r\n        ...state,\r\n        data,\r\n        isLoading: false,\r\n      };\r\n    }\r\n    case ACTION.ERROR: {\r\n      const { error, errorCode } = action;\r\n      return {\r\n        ...state,\r\n        error,\r\n        errorCode,\r\n        isLoading: false,\r\n      };\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n/**\r\n * useQuery is a custom hook that enforces consistent patterns for...\r\n *  1. retrieving data from external resources\r\n *  2. typing the values returned from external resources\r\n *  3. typing the optional query parameters available on an external resource\r\n */\r\nexport function useQuery<D, P>({\r\n  endpoint,\r\n  withCache,\r\n  params,\r\n  requestUtil = request,\r\n}: QueryProps<P>): QueryResult<D, P> {\r\n  // TODO: allow users to replace or extend this reducer\r\n  const reducer = useQueryReducer as (\r\n    prev: QueryState<D, P>,\r\n    action: QueryActions<D, P>\r\n  ) => QueryState<D, P>;\r\n  const [state, dispatch] = useReducer(reducer, {\r\n    isLoading: false,\r\n    params: params || {},\r\n    url: endpoint + URLformat({ query: { ...(params || {}) } }),\r\n  });\r\n\r\n  const {\r\n    url: urlState,\r\n    params: paramsState,\r\n    isLoading,\r\n    data,\r\n    error,\r\n    errorCode,\r\n  } = state;\r\n\r\n  const fetch = useCallback(\r\n    async (\r\n      config: {\r\n        params?: P;\r\n        options?: RequestInit;\r\n        onResponse?: (data: any) => Promise<{ data: D }>;\r\n      } = {}\r\n    ) => {\r\n      const queryParams = {\r\n        ...params,\r\n        ...config?.params,\r\n      };\r\n      const requestUrl =\r\n        endpoint +\r\n        URLformat({\r\n          // TODO: fix this\r\n          // @ts-ignore\r\n          query: { ...queryParams },\r\n        });\r\n      \r\n      // TODO: errors should not be implementation detail for hydra-query\r\n      const defaultErrorMessage =\r\n        \"Sorry, we are unable to retrieve this data for you right now. Please try again later.\";\r\n\r\n      function mountData(d: D): void {\r\n        if (withCache) {\r\n          window.localStorage.setItem(withCache, JSON.stringify(d));\r\n        }\r\n\r\n        dispatch({\r\n          type: ACTION.SUCCESS,\r\n          data: d,\r\n        });\r\n      }\r\n\r\n      try {\r\n        dispatch({\r\n          type: ACTION.REFRESH,\r\n          url: requestUrl,\r\n          params,\r\n        });\r\n        const response = await requestUtil(requestUrl, config?.options);\r\n\r\n        if (!response.ok) {\r\n          const { error } = await response.json();\r\n          dispatch({\r\n            type: ACTION.ERROR,\r\n            error: error || defaultErrorMessage,\r\n            errorCode: response.status,\r\n          });\r\n          return;\r\n        }\r\n\r\n        const payload = await response.json().catch(async () => {\r\n          // response.ok but no body\r\n          if (config?.onResponse) {\r\n            const { data: responseData } = await config.onResponse(payload);\r\n            mountData(responseData || ({} as D));\r\n            return;\r\n          }\r\n        });\r\n\r\n        if (config?.onResponse) {\r\n          const { data: responseData } = await config.onResponse(payload);\r\n          mountData(responseData);\r\n          return;\r\n        }\r\n\r\n        mountData(payload);\r\n      } catch (e) {\r\n        const { message = defaultErrorMessage } = e as { message: string };\r\n        dispatch({\r\n          type: ACTION.ERROR,\r\n          error: message,\r\n          errorCode: 500,\r\n        });\r\n      }\r\n    },\r\n    [params, endpoint, withCache, requestUtil]\r\n  );\r\n\r\n  let cachedData;\r\n  if (withCache) {\r\n    const cache = window.localStorage.getItem(withCache);\r\n    if (cache) cachedData = JSON.parse(cache);\r\n  }\r\n\r\n  // TODO: implement this\r\n  // const reset = useCallback(() => dispatch({ type: ACTION.RESET }), [dispatch]);\r\n\r\n  return {\r\n    isLoading,\r\n    endpoint,\r\n    params: paramsState,\r\n    url: urlState,\r\n    fetch,\r\n    data: cachedData || data,\r\n    error,\r\n    errorCode,\r\n    dispatch,\r\n    // reset,\r\n  };\r\n}\r\n"],"names":["URLformat","query","Object","keys","map","key","mergeRequestOptions","defaultOptions","customOptions","defaultKeys","customKeys","sharedKeys","concat","filter","k","includes","reduce","acc","defaultValue","customValue","setDefaultOptions","method","headers","mode","cache","request","url","options","opts","fetch","ACTION","useQueryReducer","state","action","type","RESET","isLoading","params","REFRESH","actionUrl","SUCCESS","data","ERROR","error","errorCode","useQuery","endpoint","withCache","requestUtil","reducer","useReducer","dispatch","urlState","paramsState","useCallback","config","mountData","d","window","localStorage","setItem","JSON","stringify","queryParams","requestUrl","defaultErrorMessage","response","json","onResponse","payload","responseData","ok","status","e","message","cachedData","getItem","parse"],"mappings":"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"}