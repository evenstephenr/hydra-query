{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useReducer, useCallback, Dispatch } from \"react\";\n\nconst URLformat = ({ query }: { query: { [k: string]: string } }) => {\n  return `?${Object.keys(query).map((key) => `${key}=${query[key]}`)}`;\n};\n\nconst mergeRequestOptions = (\n  defaultOptions: RequestInit,\n  customOptions: RequestInit = {}\n): RequestInit => {\n  const defaultKeys = Object.keys(defaultOptions);\n  const customKeys = Object.keys(customOptions);\n  const sharedKeys = defaultKeys.concat(\n    customKeys.filter((k) => !defaultKeys.includes(k))\n  );\n  return sharedKeys.reduce((acc: RequestInit, key: keyof RequestInit) => {\n    const defaultValue = defaultOptions[key];\n    const customValue = customOptions[key];\n\n    if (typeof defaultValue === \"object\" && typeof customValue === \"object\") {\n      return {\n        ...acc,\n        [key]: {\n          ...defaultValue,\n          ...customValue,\n        },\n      };\n    }\n\n    return {\n      ...acc,\n      [key]: customValue || defaultValue,\n    };\n  }, {});\n};\n\nconst setDefaultOptions = (): RequestInit => ({\n  method: \"GET\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  mode: \"cors\",\n  cache: \"no-cache\",\n});\n\nconst request = (url: string, options?: RequestInit): Promise<Response> => {\n  const defaultOptions = setDefaultOptions();\n  const opts = mergeRequestOptions(defaultOptions, options);\n  return fetch(url, opts);\n};\n\n/**\n * QueryProps defines the properties required (or optionally used) to define\n *  a useQuery hook.\n *\n * QueryProps uses generics (received from a useQuery hook) to determine the following...\n *  1. what data is accessible in the useQuery hook\n *  2. what query params exist for the useQuery hook\n */\ntype QueryProps<Params> = {\n  /** All queries require a target endpoint */\n  endpoint: string;\n  /** All queries have optional params (defaults to `undefined`) */\n  params?: Params;\n  /**\n   * useQuery defaults to using the global `fetch` browser API\n   *  - you can provide your own external request util here as needed\n   */\n  requestUtil?: (\n    url: string,\n    options?: RequestInit | undefined\n  ) => Promise<Response>;\n  /**\n   * useQuery can optionally serve cached data, rather than what's provided by an\n   *  external `fetch`\n   *  - localStorage is used for the cache\n   *  - data provided by this hook will be cached using the given key passed by `withCache`\n   *  - the data that is cached will be replaced by any use of useQuery's `requestUtil`\n   * */\n  withCache?: string;\n  // TODO: add a flag here to 'cancel' requests (prevent data from updating if parent is unmounted)\n};\n/**\n * QueryState defines the stateful properties that are returned from every instance\n *  of a useQuery hook\n */\ntype QueryState<Data, Params> = {\n  /** If an external request is currently active, isLoading will be set to `true` */\n  isLoading: boolean;\n  /** The params used in the current or most recent instance of a useQuery hook */\n  params: Params | {};\n  /** The resulting URL used in the current or most recent instance of a useQuery hook */\n  url: string;\n  /** This will always match the endpoint defined in QueryProps */\n  endpoint?: string;\n  /** The data expected to be retrieved by a useQuery hook */\n  data?: Data;\n  /** Any error thrown by a useQuery hook will be communicated here */\n  error?: string;\n  /** If an error status code is returned from an external request, it will be populated here */\n  errorCode?: number;\n};\n/**\n * QueryFetch is exported here for typing use outside of this module\n *\n * ex:\n *  type FetchSomeType = QueryFetch<{ data: SomeType }, {}>;\n */\nexport type QueryFetch<Data, Params> = (config?: {\n  params?: Params;\n  options?: RequestInit;\n  /**\n   * `onResponse` can be used to mutate the data returned from your external source\n   *  - This function defaults to a noop wrapped in a Promise that immediately resolves\n   *  - if you supply your own handler here, it must be wrapped in a promise\n   */\n  onResponse?: (\n    data: any\n  ) => Promise<{\n    data: Data;\n  }>;\n}) => void;\n/**\n * QueryResult defines the properties that are returned from every instance\n *  of a useQuery hook.\n *\n * QueryResult extends QueryState\n *\n * QueryResult uses generics (received from a useQuery hook) to determine the following...\n *  1. what data is accessible in the useQuery hook\n *  2. what query params exist for the useQuery hook\n */\ntype QueryResult<Data, Params> = QueryState<Data, Params> & {\n  /**\n   * `fetch` can be used for controlled external data retrieval from whatever context\n   *  defines a useQuery hook\n   */\n  fetch: QueryFetch<Data, Params>;\n  /**\n   * this is generally useful for testing, you can also use it to wipe the state of the hook\n   */\n  dispatch: Dispatch<QueryActions<Data, Params>>;\n};\nexport enum ACTION {\n  RESET = \"reset\",\n  REFRESH = \"refresh\",\n  SUCCESS = \"success\",\n  ERROR = \"error\",\n}\ntype RESET_ACTION = { type: ACTION.RESET };\ntype REFRESH_ACTION<P> = {\n  type: ACTION.REFRESH;\n  url: string;\n  params?: P | {};\n};\ntype SUCCESS_ACTION<D> = {\n  type: ACTION.SUCCESS;\n  data: D;\n  prevPage?: string;\n  nextPage?: string;\n};\ntype ERROR_ACTION = { type: ACTION.ERROR; error: string; errorCode?: number };\ntype QueryActions<D, P> =\n  | RESET_ACTION\n  | REFRESH_ACTION<P>\n  | SUCCESS_ACTION<D>\n  | ERROR_ACTION;\nexport function useQueryReducer<Data, Params>(\n  state: QueryState<Data, Params>,\n  action: QueryActions<Data, Params>\n): QueryState<Data, Params> {\n  switch (action.type) {\n    case ACTION.RESET: {\n      return {\n        isLoading: false,\n        url: state.url,\n        params: state.params,\n      };\n    }\n    case ACTION.REFRESH: {\n      const { url: actionUrl, params = {} } = action;\n      return {\n        ...state,\n        url: actionUrl,\n        params,\n        isLoading: true,\n      };\n    }\n    case ACTION.SUCCESS: {\n      const { data } = action;\n      return {\n        ...state,\n        data,\n        isLoading: false,\n      };\n    }\n    case ACTION.ERROR: {\n      const { error, errorCode } = action;\n      return {\n        ...state,\n        error,\n        errorCode,\n        isLoading: false,\n      };\n    }\n    default:\n      return state;\n  }\n}\n/**\n * useQuery is a custom hook that enforces consistent patterns for...\n *  1. retrieving data from external resources\n *  2. typing the values returned from external resources\n *  3. typing the optional query parameters available on an external resource\n */\nexport function useQuery<D, P>({\n  endpoint,\n  withCache,\n  params,\n  requestUtil = request,\n}: QueryProps<P>): QueryResult<D, P> {\n  const reducer = useQueryReducer as (\n    prev: QueryState<D, P>,\n    action: QueryActions<D, P>\n  ) => QueryState<D, P>;\n  const [state, dispatch] = useReducer(reducer, {\n    isLoading: false,\n    params: params || {},\n    url: endpoint + URLformat({ query: { ...(params || {}) } }),\n  });\n\n  const {\n    url: urlState,\n    params: paramsState,\n    isLoading,\n    data,\n    error,\n    errorCode,\n  } = state;\n\n  const fetch = useCallback(\n    async (\n      config: {\n        params?: P;\n        options?: RequestInit;\n        forcedEndpoint?: string;\n        onResponse?: (data: any) => Promise<{ data: D }>;\n      } = {}\n    ) => {\n      const queryParams = {\n        ...params,\n        ...config?.params,\n      };\n      const requestUrl =\n        (config?.forcedEndpoint || endpoint) +\n        URLformat({\n          // @ts-ignore\n          query: { ...queryParams },\n        });\n      const defaultErrorMessage =\n        \"Sorry, we are unable to retrieve this data for you right now. Please try again later.\";\n\n      function mountData(d: D): void {\n        if (withCache) {\n          window.localStorage.setItem(withCache, JSON.stringify(d));\n        }\n\n        dispatch({\n          type: ACTION.SUCCESS,\n          data: d,\n        });\n      }\n\n      try {\n        dispatch({\n          type: ACTION.REFRESH,\n          url: requestUrl,\n          params,\n        });\n        const response = await requestUtil(requestUrl, config?.options);\n\n        if (!response.ok) {\n          const { error } = await response.json();\n          dispatch({\n            type: ACTION.ERROR,\n            error: error || defaultErrorMessage,\n            errorCode: response.status,\n          });\n          return;\n        }\n\n        const payload = await response.json().catch(async () => {\n          // response.ok but no body\n          if (config?.onResponse) {\n            const { data: responseData } = await config.onResponse(payload);\n            mountData(responseData || ({} as D));\n            return;\n          }\n        });\n\n        if (config?.onResponse) {\n          const { data: responseData } = await config.onResponse(payload);\n          mountData(responseData);\n          return;\n        }\n\n        mountData(payload);\n      } catch (e) {\n        const { message = defaultErrorMessage } = e as { message: string };\n        dispatch({\n          type: ACTION.ERROR,\n          error: message,\n          errorCode: 500,\n        });\n      }\n    },\n    [params, endpoint, withCache, requestUtil]\n  );\n\n  let cachedData;\n  if (withCache) {\n    const cache = window.localStorage.getItem(withCache);\n    if (cache) cachedData = JSON.parse(cache);\n  }\n\n  return {\n    isLoading,\n    endpoint,\n    params: paramsState,\n    url: urlState,\n    fetch,\n    data: cachedData || data,\n    error,\n    errorCode,\n    dispatch,\n  };\n}\n"],"names":["URLformat","query","Object","keys","map","key","mergeRequestOptions","defaultOptions","customOptions","defaultKeys","customKeys","sharedKeys","concat","filter","k","includes","reduce","acc","defaultValue","customValue","setDefaultOptions","method","headers","mode","cache","request","url","options","opts","fetch","ACTION","useQueryReducer","state","action","type","RESET","isLoading","params","REFRESH","actionUrl","SUCCESS","data","ERROR","error","errorCode","useQuery","endpoint","withCache","requestUtil","reducer","useReducer","dispatch","urlState","paramsState","useCallback","config","mountData","d","window","localStorage","setItem","JSON","stringify","queryParams","requestUrl","forcedEndpoint","defaultErrorMessage","response","json","onResponse","payload","responseData","ok","status","e","message","cachedData","getItem","parse"],"mappings":"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"}